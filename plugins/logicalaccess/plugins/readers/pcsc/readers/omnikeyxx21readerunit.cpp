/**
 * \file omnikeyxx21readerunit.cpp
 * \author Maxime C. <maxime@leosac.com>
 * \brief Omnikey XX21 reader unit.
 */

#include <logicalaccess/plugins/readers/pcsc/readers/omnikeyxx21readerunit.hpp>

#include <iostream>
#include <iomanip>
#include <sstream>

#include <logicalaccess/windowsregistry.hpp>

#include <logicalaccess/plugins/readers/pcsc/readers/omnikeyxx21readerunitconfiguration.hpp>
#include <logicalaccess/plugins/readers/pcsc/readercardadapters/pcscreadercardadapter.hpp>
#include <logicalaccess/myexception.hpp>
#include <logicalaccess/dynlibrary/librarymanager.hpp>
#include <logicalaccess/cards/commands.hpp>

#include <boost/regex.hpp>
#if defined(__unix__)
#include <PCSC/reader.h>
#elif defined(__APPLE__)

#ifndef SCARD_CTL_CODE
#define SCARD_CTL_CODE(code) (0x42000000 + (code))
#endif

#include <PCSC/winscard.h>
#include <PCSC/wintypes.h>
#endif

#define CM_IOCTL_GET_SET_RFID_BAUDRATE SCARD_CTL_CODE(3215)

namespace logicalaccess
{
std::map<std::string, OmnikeyXX21ReaderUnit::SecureModeStatus>
    OmnikeyXX21ReaderUnit::secure_connection_status_;

OmnikeyXX21ReaderUnit::OmnikeyXX21ReaderUnit(const std::string &name)
    : OmnikeyReaderUnit(name)
{
    d_readerUnitConfig.reset(new OmnikeyXX21ReaderUnitConfiguration());
}

OmnikeyXX21ReaderUnit::~OmnikeyXX21ReaderUnit()
{
}

PCSCReaderUnitType OmnikeyXX21ReaderUnit::getPCSCType() const
{
    return PCSC_RUT_OMNIKEY_XX21;
}

bool OmnikeyXX21ReaderUnit::waitRemoval(unsigned int maxwait)
{
    bool removed = OmnikeyReaderUnit::waitRemoval(maxwait);
    if (removed)
    {
        setSecureConnectionStatus(SecureModeStatus::DISABLED);
    }

    return removed;
}

std::shared_ptr<ReaderCardAdapter>
    OmnikeyXX21ReaderUnit::getReaderCardAdapter(std::string /*type*/)
{
    return getDefaultReaderCardAdapter();
}

void OmnikeyXX21ReaderUnit::changeReaderKey(
    std::shared_ptr<ReaderMemoryKeyStorage> keystorage, const ByteVector &key)
{
    EXCEPTION_ASSERT_WITH_LOG(keystorage, std::invalid_argument,
                              "Key storage must be defined.");
    EXCEPTION_ASSERT_WITH_LOG(key.size() > 0, std::invalid_argument,
                              "key cannot be empty.");

    std::shared_ptr<PCSCReaderCardAdapter> rca = getDefaultPCSCReaderCardAdapter();

    uint8_t key_loc = (keystorage->getVolatile() ? 0x00 : 0x20);
    if (keystorage->getKeySlot() == 0x80 || keystorage->getKeySlot() == 0x81 ||
        keystorage->getKeySlot() == 0x82)
    {
        // We want to change either the session read key, session write key, or the
        // HID encryption key. Those keys are considered "reader key" and therefor need
        // this flags.
        key_loc |= 1 << 7;
    }
    rca->sendAPDUCommand(0x84, 0x82, key_loc, keystorage->getKeySlot(),
                         static_cast<unsigned char>(key.size()), key);
}

void OmnikeyXX21ReaderUnit::getT_CL_ISOType(bool &isTypeA, bool &isTypeB)
{
    unsigned char outBuffer[64];
    unsigned char inBuffer[2];
    DWORD dwControlCode = CM_IOCTL_GET_SET_RFID_BAUDRATE;

    memset(outBuffer, 0x00, sizeof(outBuffer));
    DWORD dwOutBufferSize = sizeof(outBuffer);
    DWORD dwInBufferSize  = sizeof(inBuffer);
    DWORD dwBytesReturned = 0;

    inBuffer[0] = 0x01; // Version of command
    inBuffer[1] = 0x00; // Get asymmetric baud rate information

    isTypeA = false;
    isTypeB = false;

    DWORD dwStatus =
        SCardControl(getHandle(), dwControlCode, (LPVOID)inBuffer, dwInBufferSize,
                     (LPVOID)outBuffer, dwOutBufferSize, &dwBytesReturned);
    if (dwStatus == SCARD_S_SUCCESS && dwBytesReturned >= 10)
    {
        switch (outBuffer[9])
        {
        case 0x04: isTypeA = true; break;

        case 0x08: isTypeB = true; break;
        default:;
        }
    }
}

void OmnikeyXX21ReaderUnit::setSecureConnectionStatus(SecureModeStatus st)
{
    auto itr = secure_connection_status_.find(getConnectedName());
    if (itr != secure_connection_status_.end())
        itr->second = st;
    else
        secure_connection_status_.insert(make_pair(getConnectedName(), st));
}

OmnikeyXX21ReaderUnit::SecureModeStatus OmnikeyXX21ReaderUnit::getSecureConnectionStatus()
{
    const auto itr = secure_connection_status_.find(getConnectedName());
    if (itr == secure_connection_status_.end())
        return SecureModeStatus(SecureModeStatus::DISABLED);
    return itr->second;
}

void OmnikeyXX21ReaderUnit::setSecureConnectionStatus(int v)
{
    setSecureConnectionStatus(SecureModeStatus(v));
}

void OmnikeyXX21ReaderUnit::setCardTechnologies(const TechnoBitset &bitset)
{
#ifdef _WIN32
    // We are not (yet) able to do so on Linux.

    // The registry values are mapped to card techno.
    // This is the mapping for the Omnikey driver.
    //     ICLASS15693  -> 02
    //     ISO15693     -> 04
    //     ICODE1       -> 06
    //     STM14443B    -> 05
    //     ISO14443B    -> 03
    //     ISO14443A    -> 01

    ByteVector data;
    if (bitset & Techno::ICLASS_15693)
        data.push_back(0x02);
    if (bitset & Techno::ISO_15693)
        data.push_back(0x04);
    if (bitset & Techno::ICODE1)
        data.push_back(0x06);
    if (bitset & Techno::STM14443B)
        data.push_back(0x05);
    if (bitset & Techno::ISO_14443_B)
        data.push_back(0x03);
    if (bitset & Techno::ISO_14443_A)
        data.push_back(0x01);

    if (data.size() == 0)          // Nothing means all techno are disabled,
                                   // however no registry key
        data = {0, 0, 0, 0, 0, 0}; // means (for the driver) that all is enabled.
    if (!WindowsRegistry::writeBinary("SYSTEM\\CurrentControlSet\\Control\\CardMan\\RFID",
                                      "CardSearch", data))
    {
        THROW_EXCEPTION_WITH_LOG(LibLogicalAccessException,
                                 "Cannot set card technologies.");
    }
#else
    std::ifstream file("/etc/omnikey.ini");
    std::vector<std::string> lines;
    std::string str;
    while (std::getline(file, str))
    {
        lines.push_back(std::move(str));
    }
    if (!file.good() && !file.eof())
    {
        THROW_EXCEPTION_WITH_LOG(LibLogicalAccessException,
                                 "Cannot read /etc/omnikey.ini");
    }
    file.close();
    std::map<std::string, bool> technos;
    technos["ICLASS15693"] = bitset & Techno::ICLASS_15693;
    technos["ISO15693"]    = bitset & Techno::ISO_15693;
    technos["ICODE1"]      = bitset & Techno::ICODE1;
    technos["ISO14443A"]   = bitset & Techno::ISO_14443_A;
    technos["ISO14443B"]   = bitset & Techno::ISO_14443_B;
    technos["STM14443B"]   = bitset & Techno::STM14443B;
    replaceCardTechnoLinux(lines, technos);
#endif
}


TechnoBitset OmnikeyXX21ReaderUnit::getCardTechnologies()
{
    TechnoBitset bs = 0;
#ifdef _WIN32
    ByteVector data;
    if (WindowsRegistry::readBinary("SYSTEM\\CurrentControlSet\\Control\\CardMan\\RFID",
                                    "CardSearch", data))
    {
        if (find(data.begin(), data.end(), 0x02) != data.end())
            bs |= Techno::ICLASS_15693;
        if (find(data.begin(), data.end(), 0x04) != data.end())
            bs |= Techno::ISO_15693;
        if (find(data.begin(), data.end(), 0x06) != data.end())
            bs |= Techno::ICODE1;
        if (find(data.begin(), data.end(), 0x05) != data.end())
            bs |= Techno::STM14443B;
        if (find(data.begin(), data.end(), 0x03) != data.end())
            bs |= Techno::ISO_14443_B;
        if (find(data.begin(), data.end(), 0x01) != data.end())
            bs |= Techno::ISO_14443_A;
    }
    else
        THROW_EXCEPTION_WITH_LOG(LibLogicalAccessException,
                                 "Cannot retrieve card technologies.");
#else
    // On Linux, edit /etc/omnikey.ini if available.
    std::ifstream file("/etc/omnikey.ini");
    std::vector<std::string> lines;
    std::string str;
    while (std::getline(file, str))
    {
        lines.push_back(std::move(str));
    }
    if (!file.good() && !file.eof())
    {
        THROW_EXCEPTION_WITH_LOG(LibLogicalAccessException,
                                 "Cannot read /etc/omnikey.ini");
    }

    if (fetchCardTechoLinux(lines, "ISO14443A"))
        bs |= Techno::ISO_14443_A;
    if (fetchCardTechoLinux(lines, "ISO14443B"))
        bs |= Techno::ISO_14443_B;
    if (fetchCardTechoLinux(lines, "ICLASS15693"))
        bs |= Techno::ICLASS_15693;
    if (fetchCardTechoLinux(lines, "ISO15693"))
        bs |= Techno::ISO_15693;
    if (fetchCardTechoLinux(lines, "STM14443B"))
        bs |= Techno::STM14443B;
    if (fetchCardTechoLinux(lines, "ICODE1"))
        bs |= Techno::ICODE1;
#endif
    return bs;
}

TechnoBitset OmnikeyXX21ReaderUnit::getPossibleCardTechnologies()
{
    using namespace Techno;
    TechnoBitset tb =
        (ICLASS_15693 | ISO_15693 | ICODE1 | STM14443B | ISO_14443_B | ISO_14443_A);
    return tb;
}

LLA_READERS_PCSC_API std::ostream &
operator<<(std::ostream &os, const OmnikeyXX21ReaderUnit::SecureModeStatus &s)
{
    using sms = OmnikeyXX21ReaderUnit::SecureModeStatus;
    switch (s.value_)
    {
    case sms::READ: os << "READ ONLY"; break;
    case sms::WRITE: os << "WRITE"; break;
    case sms::DISABLED: os << "DISABLED"; break;
    default:;
    }
    return os;
}

bool OmnikeyXX21ReaderUnit::fetchCardTechoLinux(const std::vector<std::string> &lines,
                                                const std::string &techno)
{
    auto find_line = [&](const std::string &s) -> bool {

        boost::regex r("^" + techno + "(\\s)?=(\\s)?\\d$");
        if (regex_match(s, r))
        {
            return true;
        }
        return false;
    };

    auto itr = std::find_if(lines.begin(), lines.end(), find_line);
    if (itr != lines.end())
    {
        boost::smatch match;
        boost::regex r(".*(\\d)$");
        auto ret = boost::regex_search(*itr, match, r);
        if (ret)
        {
            if (match.size() == 2 && match[1] == '1')
            {
                return true;
            }
        }
    }
    return false;
}

bool OmnikeyXX21ReaderUnit::replaceCardTechnoLinux(
    std::vector<std::string> &lines, const std::map<std::string, bool> technos)
{
    for (auto map_itr : technos)
    {
        auto find_line = [&](const std::string &s) -> bool {

            boost::regex r("^" + map_itr.first + "(\\s)?=(\\s)?\\d$");
            if (regex_match(s, r))
            {
                return true;
            }
            return false;
        };
        auto line_itr = std::find_if(lines.begin(), lines.end(), find_line);
        if (line_itr != lines.end())
        {
            *line_itr = map_itr.first + " = " + (map_itr.second ? "1" : "0");
        }
    }

    std::ofstream of("/etc/omnikey.ini", std::ios_base::trunc);
    for (auto &line : lines)
        of << line << '\n';
    if (!of.good())
    {
        THROW_EXCEPTION_WITH_LOG(LibLogicalAccessException,
                                 "Cannot set card technologies"
                                 " because we fail to write to reader's config file.");
    }
    return true;
}

ReaderServicePtr OmnikeyXX21ReaderUnit::getService(const ReaderServiceType &type)
{
    if (type == RST_LICENSE_CHECKER)
    {
        // The implementation for this service actually lives in LLA-private.
        // We rely on the LibraryManager to grab a instance of the service.
        return LibraryManager::getInstance()->getReaderService(shared_from_this(), type);
    }
    return nullptr;
}
}
